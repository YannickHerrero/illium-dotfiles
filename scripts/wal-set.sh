#!/bin/sh
# wal-set.sh — set wallpaper and propagate pywal16 colors to all tools
# Usage: wal-set.sh [--light|--dark] <path-to-wallpaper>
#
# Without flags, auto-detects whether the image is light or dark using
# average brightness (requires python-pillow). Falls back to dark mode
# if detection fails.

# ─── Parse optional --light / --dark override ─────────────────────
FORCE_MODE=""
case "$1" in
    --light) FORCE_MODE="light"; shift ;;
    --dark)  FORCE_MODE="dark";  shift ;;
esac

if [ -z "$1" ]; then
    echo "Usage: wal-set.sh [--light|--dark] <path-to-wallpaper>"
    exit 1
fi

if [ ! -f "$1" ]; then
    echo "Error: file '$1' not found"
    exit 1
fi

# ─── Detect image brightness ─────────────────────────────────────
# Downsample to 50x50, convert to grayscale, compute mean pixel value.
# Images above the threshold (140/255) are treated as light.
if [ -n "$FORCE_MODE" ]; then
    MODE="$FORCE_MODE"
else
    MODE=$(python3 -c "
from PIL import Image
im = Image.open('$1').convert('L')
im.thumbnail((50, 50))
px = list(im.getdata())
print('light' if sum(px) / len(px) > 140 else 'dark')
" 2>/dev/null) || MODE="dark"
    [ -z "$MODE" ] && MODE="dark"
fi

LIGHT_FLAG=""
[ "$MODE" = "light" ] && LIGHT_FLAG="-l"

echo "Detected mode: $MODE"

# ─── Generate color scheme (skip setting wallpaper, we use feh) ────
wal -i "$1" -n $LIGHT_FLAG

# ─── Set wallpaper ─────────────────────────────────────────────────
feh --bg-fill "$1"

# ─── Merge pywal Xresources into live X server ────────────────────
# This updates the resource database so dwm, st, and dmenu pick up
# the new colors. Also triggers PropertyNotify on root window for st
# live reload.
if [ -f "$HOME/.cache/wal/colors.Xresources" ]; then
    xrdb -merge "$HOME/.cache/wal/colors.Xresources"
fi

# ─── Read all 16 colors in a single python call ───────────────────
COLORS_JSON="$HOME/.cache/wal/colors.json"

if [ -f "$COLORS_JSON" ]; then
    eval "$(python3 -c "
import json, sys
with open('$COLORS_JSON') as f:
    c = json.load(f)['colors']
for i in range(16):
    print(f'color{i}=\"{c[\"color\" + str(i)]}\"')
print(f'background=\"{c[\"color0\"]}\"')
print(f'foreground=\"{c[\"color7\"]}\"')
")"
fi

# ─── Generate neovim base16 theme-colors.lua ──────────────────────
NVIM_THEME="$HOME/.config/nvim/lua/theme-colors.lua"

if [ -n "$color0" ]; then
    mkdir -p "$(dirname "$NVIM_THEME")"
    cat > "$NVIM_THEME" << EOF
-- Auto-generated by wal-set.sh - DO NOT EDIT
return {
  base16 = {
    base00 = "$color0",
    base01 = "$color8",
    base02 = "$color8",
    base03 = "$color3",
    base04 = "$color4",
    base05 = "$color7",
    base06 = "$color15",
    base07 = "$color15",
    base08 = "$color1",
    base09 = "$color9",
    base0A = "$color3",
    base0B = "$color2",
    base0C = "$color6",
    base0D = "$color4",
    base0E = "$color5",
    base0F = "$color14",
  }
}
EOF
    echo "Generated neovim theme: $NVIM_THEME"
fi

# ─── Generate dunstrc from template ───────────────────────────────
DUNST_BASE="$HOME/.config/dunst/dunstrc.base"
DUNST_RC="$HOME/.config/dunst/dunstrc"

if [ -f "$DUNST_BASE" ] && [ -n "$color0" ]; then
    sed -e "s/%%BACKGROUND%%/$color0/g" \
        -e "s/%%FOREGROUND%%/$color7/g" \
        -e "s/%%ACCENT%%/$color4/g" \
        -e "s/%%MUTED%%/$color8/g" \
        -e "s/%%BORDER%%/$color8/g" \
        -e "s/%%ALERT%%/$color1/g" \
        "$DUNST_BASE" > "$DUNST_RC"
    echo "Generated dunstrc: $DUNST_RC"
    pkill dunst 2>/dev/null
    dunst &
fi

# ─── Signal dwm to reload colors ──────────────────────────────────
pidof dwm > /dev/null 2>&1 && kill -USR1 "$(pidof dwm)"

# ─── Recolor all running terminals ────────────────────────────────
# Write pywal escape sequences to every open pseudo-terminal to
# reprogram their 16-color palette in-place. Oh-my-posh uses palette
# indices so prompt colors update on next redraw.
if [ -f "$HOME/.cache/wal/sequences" ]; then
    for term in /dev/pts/*; do
        [ -w "$term" ] && cat "$HOME/.cache/wal/sequences" > "$term" 2>/dev/null
    done
fi
